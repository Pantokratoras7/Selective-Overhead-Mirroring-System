Γαρμπής Παναγιώτης-Ορέστης                            1115201400025

-Το σύνολο των προγραμμάτων υλοποιείται πλήρως και παρουσιάζει θεμιτά αποτελέσματα. Οι δοκιμές αυτών έγιναν με συνδέσεις μέσω
 localhost (σε ubuntu 16.04), όπου δεν παρουσιάστηκε κάποιο πρόβλημα κατά τις συνδέσεις των προγραμμάτων.

-Ο MirrorInitiator διαβάζει τα ορίσματα από την γραμμή εντολών, συνενώνει αυτά που αφορούν τους ContentServers και τα στέλνει
 ως client μέσω νέας σύνδεσης στον MirrorServer που δίνεται από την γραμμή εντολών. Αφότου ο MirrorServer ολοκληρώσει την
 δουλειά που του ανατέθηκε, στέλνει ένα μήνυμα με στατιστικά στοιχεία στον MirrorInitiator, ο οποίος τα εκτυπώνει και τερματίζει.

-Ο MirrorServer κατά την έναρξή του, δημιουργεί τον φάκελο που θα αποθηκεύσει ό,τι αρχεία του ζητηθούν, τους workers οι οποίοι
 και λειτουργούν συνεχώς, ενώ ενεργοποιεί και το socket του στο port που του ζητείται περιμένοντας συνδέσεις από clients. Όταν
 λάβει κάποια σύνδεση, δημιουργεί ένα ξεχωριστό thread για να την ικανοποιήσει. Το πρόγραμμα συνεχίζει την λειτουργία του
 περιμένοντας νέα αιτήματα συνδέσεων, και τερματίζει με Ctrl-C, τερματίζοντας τους workers και ελευθερώνοντας τόσο τα mutexes και
 τα conditional variables, όσο και ο,τιδήποτε δεσμεύτηκε δυναμικά (μέσω signal handler).

-Όταν ο MirrorServer δέχεται μία σύνδεση, δημιουργεί όσους Mirrormanagers χρειάζεται, ώστε αυτοί να επικοινωνήσουν με τους
 ContentServers. Ο καθένας από αυτούς στέλνει στον αντίστοιχο ContentServer αιτήματα LIST, και λαμβάνει το σύνολο των μονοπατιών
 που υπάρχει στον φάκελο που εξυπηρετεί ο ContentServer. Αυτά τα μονοπάτια τα γράφει σε ένα προσωρινό και διακριτό αρχείο, από
 όπου και ελέγχεται αν το εκάστοτε μονοπάτι ανήκει στην ακολουθία αρχείων και καταλόγων που ζητήθηκε από τον MirrorInitiator. Αν
 όντως ανήκει, τότε αποστέλλεται το μονοπάτι αυτό στον Buffer, μαζί με την διεύθυνση, την θύρα υποδοχής και την καθυστέρηση που
 υποκειται η επικείμενη μεταφορά από τον συγκεκριμένο ContentServer. Όταν ολοκληρωθεί το διάβασμα, το προσωρινό αρχείο διαγράφεται,
 ενώ αν αυτή ήταν η τελευταία συσκευή που ικανοποιήθηκε το αίτημα LIST, στέλνει και ένα επιπλέον μήνυμα τέλους στον Buffer, το
 οποίο και θα χειριστούν καταλλήλως οι workers για τον τερματισμό της συγκεκριμένης διεργασίας.

-Η υλοποίηση του Buffer είναι ουσιαστικά μία ουρά, που κάθε string με τις απαιτούμενες πληροφορίες από τους MirrorManagers εισάγεται
 και εξάγεται από αυτόν με την χρήση mutexes και condition variables, τόσο για την απαιτούμενη ασύγχρονη εισαγωγή των πληροφοριών
 αυτών από τα mirror threads, όσο και για πιθανή αναμονή όταν ο buffer είναι γεμάτος ή άδειος.

-Οι workers (που και αυτοί είναι threads), λαμβάνουν τα δεδομένα από τον buffer, και με βάση αυτά αιτούνται μία νέα αίτηση στον
 δοθέν ContentServer. Όταν αυτή γίνει δεκτή, αποστέλλουν ένα αίτημα FETCH, δίνοντας το μονοπάτι και την αντίστοιχη καθυστέρηση
 που η μεταφορά αρχείου θα πρέπει να υπόκειται. Έπειτα λαμβάνουν από τον ContentServer τον τύπο αυτού που ζητήθηκε (αρχείο ή φάκελος),
 και το μέγεθός του. Αν είναι αρχείο, ο εκάστοτε worker λαμβάνει μέσω της recv τα δεδομένα του αρχείου που βρίσκεται στον
 ContentServer και τα αντιγράφει σε ένα νέο αρχείο που μόλις δημιουργήθηκε με τον ίδιο όνομα. Αν το μονοπάτι που πρέπει αυτό το
 αρχείο να υπόκειται δεν έχει δημιουργηθεί στον φάκελο όπου πρέπει να αποθηκευτούν τα δεδομένα στον υπολογιστή του MirrorServer,
 τότε δημιουργείται με mkdir. Έτσι δημιουργούνται και οι φάκελοι που επιστρέφονται από τον ContentServer (εφόσον δεν είναι αρχεία
 δεν υπάρχει κάτι για να αντιγράψουμε, απλά δημιουργούμε την σωστή ιεραρχία φακέλων).

-Ο κάθε ContentServer κατά την έναρξή του, δημιουργεί μία νέα σύνδεση και περιμένει αιτήματα LIST και FETCH από κάποιον MirrorServer.
 Αν το αίτημα που λαμβάνει είναι LIST, τότε από τον φάκελο που μπορεί να διαθέσει τα αρχεία αντιγράφει όλα τα μονοπάτια προς κάθε
 υποφάκελο και αρχείο σε ένα προσωρινό αρχείο, του οποίου τα δεδομένα και στέλνει στους MirrorManagers που τον καλέσανε. Αντίστοιχα
 στέλνει και τα αρχεία που ζητούνται μέσω FETCH, απλά εδώ αν είναι αρχείο υπόκειται στην καθυστέρηση μεταφοράς delay, ενώ αν είναι
 φάκελος, δεν στέλνει κάτι πίσω στους workers του MirrorServer, πλην του ονόματός του και το ότι είναι φάκελος. Κάθε σύνδεση που
 δέχεται ο ContentServer την υλοποιεί με fork (παρόμοια με τον server που απλώς εκεί αντί για fork χρησιμοποιούνται threads). Όπως
 και ο MirrorServer, τερματίζεται με Ctrl-C.

-Τα αρχεία functions.c, functions.h και structs.h είναι απαραίτητα για όλα τα εκτελέσιμα, οπότε δεν πρέπει σε καμία περίπτωση να
 παραληφθούν. Στο αρχείο MirrorServer.c, υπάρχει η υλοποίηση κάποιων συναρτήσεων, ώστε να μπορούν να χρησιμοποιηθούν με αποδοτικό
 τρόπο οι καθολικές μεταβλητές και τα mutexes με τα condition variables. Επίσης, αν θέλουμε να μεταβάλουμε το μέγεθος του buffer,
 θα πρέπει να τροποποιήσουμε την define μεταβλητή BUFFERSIZE τόσο στο functions.c, όσο και στο structs.h.

-Πέραν του MirrorInitiator, διάφορα μηνύματα εκτυπώνονται και στα MirrorServer και ContentServer, ώστε να φανεί η ροή της όλης
 διαδικασίας. Αν και δεν είναι απαραίτητα, υπάρχουν και λίγες ακόμη εκτυπώσεις αλλά σε σχόλια.

-Υπάρχουν αναλυτικά σχόλια στον κώδικα. Δίνεται makefile για όλα τα εκτελέσιμα.
